### 多线程

#### 1、基本概念

**程序：**wechat.exe

**进程：**wechat.exe启动后，叫做一个进程，是相对于程序来说的，是个动态的概念

**线程：**作为一个进程里面最小的执行单元就叫一个线程，或者说，一个程序里不同的执行路径就叫做一个线程

```java
package com.steven.shi.javastudy.server;

public class ThreadDemo {

    private static class Th1 extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Th1");
            }
        }
    }

    public static void main(String[] args) {
      	//new Th1().run();  //如果调用run方法，那么会先去执行run方法，等执行完之后，再执行下面的主程序
        new Th1().start(); //调用此方法，下面的主程序继续运行，于此同时，run方法同时运行（这就是不同的线程；即一个程序里，不同的执行路径即为一个线程）
        for (int i = 0; i < 10; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("main");
        }
    }
}

//运行结果：我们发现Th1和main交替打印
main
Th1
main
Th1
main
Th1
main
Th1
main
Th1
```

#### 2、创建线程的两种方式

#####  a、继承Thread，重写run方法

```java
 private static class Th1 extends Thread {
        @Override
        public void run() {
           //TODO:
        }
    }
```

##### b、定义一个类，实现Runnable接口，重写run方法

```java
    public static class Th2 implements Runnable {

        /**
         * When an object implementing interface <code>Runnable</code> is used
         * to create a thread, starting the thread causes the object's
         * <code>run</code> method to be called in that separately executing
         * thread.
         * <p>
         * The general contract of the method <code>run</code> is that it may
         * take any action whatsoever.
         *
         * @see Thread#run()
         */
        @Override
        public void run() {

        }
    }
```

#### 3、启动线程的5种方式(基于以上创建的线程)

```java
        //1、
        new Th1().start();
        //2、
        new Thread(new Th2()).start();

        //3、lambda
        new Thread(() -> {
            System.out.println("");
        }).start();
        //4、FutureTask +Callable
        Thread t = new Thread(new FutureTask<String>(new MyCall()));
        t.start();

        //5、通过线程池
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(() -> {
            System.out.printf("");
        });
        service.shutdown();
```

#### 4、线程的几个方法

- a、```Sleep```:睡眠，当前线程暂停后，就会释放CPU资源，让给其他线程去运行

  CPU一直是从内存中获取指令，运行，没有指令了，就不运行了

  如何唤醒？由设置的睡眠时间决定，等到了设置的时间自动唤醒。

  ```java
  private static class Th1 extends Thread {
          @Override
          public void run() {
              for (int i = 0; i < 10; i++) {
                  try {
                      Thread.sleep(1000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  ```

- b、```Yield```:非常谦让的让出一下CPU 
  当前线程正在执行的时候停下来进入等待队列，让出CPU一下，调度算法会拿等待的线程执行，当然也有可能拿刚刚加入等待队列中的线程继续执行

```java
    public static void main(String[] args) {

        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                if (i % 10 == 0) {
                    Thread.yield();
                }
            }
        }).start();
    }
```

- ```Join```:加入，在自己当前的线程中加入其它线程，当前线程等待，等调用的线程运行完了，自己再去执行；如下。th3在运行的时候，join了th1,那么th3等待th1执行完成之后，再去执行
  注意：在th3内部join自己是没有意义的；

  ```java
          Thread th1 = new Thread(() -> {
              for (int i = 0; i < 10; i++) {
                  try {
                      Thread.sleep(1000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          });
  
          Thread th3 = new Thread(() -> {
              try {
                  th1.join();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          });
  ```

#### 5、线程的状态

可以通过	```t.getState()```获取到线程的状态

先来看一张线程状态迁移图：

![image-20200601163815062](/Users/Steven/GitRepositories/JavaStudyNotes/docs/assets/image-20200601163815062.png)

1. **新建状态：**当new一个线程的时候，并没有调用start方法的时候，该线程处于新建状态；

2. **Runnable：**线程对象调用start方法，会被线程调度器执行，即交给操作系统执行，操作系统在执行的时候，这个状态叫做Runnable

   - **Ready就绪状态：**放到CPU的等待队列等待CPU执行；
   - **Running运行状态：**被CPU执行时的状态；

   注意：调用Yiled的时候，线程会从Running状态变成Ready状态，等到线程调度器拿到并且执行的时候又会从Ready变成Running状态

3. **Teminated结束状态：**线程执行完了就会变成这个状态，需要注意的是，线程执行完了之后，就不能再调用start方法了；

4. **TimedWaiting等待状态：**（即按照时长等待，过了时长就又回到了等待队列）```Thread.sleep(time)```、```wait(time)```、```join(time)```、```LockSupport.parkNanos()```、```LockSupport.parkUntil()```等

5. **Waiting等待状态：**运行的时候调用了```wait()```、```join()```	```LockSupport.park()```则会进去Waiting状态；对应的，调用了```notify()```、```notifiAll()```、```LockSupport.unpark```就会回到Running状态；

6. **Blocked阻塞状态：**比如加了锁```synchronized```,在同步的代码中没有获得锁就会阻塞状态，获得锁之后就会到等待队列，等到CPU执行

其中，4、5、6三个状态为Runnable中的变迁状态；

> **问题：**上面这些状态，哪些是JVM管理的，哪些是操作系统管理的？
>
> 上面的状态都是有JVM管理的，因为JVM管理的时候也要通过操作系统。操作系统和JVM是分不开的；JVM是操作系统上的一个程序

> **问题：**线程什么状态的时候是被挂起的，挂起是否是一个状态？
>
> 

在一个CPU上会跑好多个线程，线程从Running状态回到Ready状态叫做被挂起 

**注意：不要去关闭线程```stop()```,关闭线程就是要让一个线程正常结束，而不是使用```stop()``` 去结束线程，这样容易导致状态不一致。**



#### 附【知识点】：```synchronized关键字```

多线程去访问同一个资源的时候需要对这个资源上锁，任何线程需要访问资源的时候，必须先拿到锁；举个很简单的例子就很容易理解为什么需要锁：两个线程同时读取并操作同一个变量，其中一个线程讲内存中的变量读到自己的内存中，然后修改了该变量的值（+1），另一个线程也同时执行这个操作，最终的正确结果应该是2，但是出来的结果是1

注意：这把锁并不是对数字进行上锁，你可以任意指定；比如，你如果想操作变量i，可以先拿到一个对象O的锁，而不一定是对数字加锁；

##### ```synchronized```的特性

如果说每次定义一个锁的对象```Object o``` ,都需要new出来，那么加锁的时候太麻烦，所以有一个简单的方式就是```synchronized(this)```所得当前对象，或者在方法上添加```synchronized```

```java
package com.steven.shi.javastudy.server;

public class T {
    public static int count = 10;

    public synchronized static void test() {
        count--;
    }

    public void test1() {
        synchronized (this) {
            count--;
        }
    }
    //以上两个方法是等值的
}
```

我们知道静态方法static是没有this对象的，所以不需要new 出来一个对象就可以执行这个方法，但是如果这个上面加```synchronized```的话，就代表```synchronized(T.class)```,这里```synchronized(T.class)```锁的就是T这个对象

> **问题：**T.class是单例的嘛？
>
>  如果是在同一个ClassLoader空间那它一定是单例的，不是同一个类加载器就不是了，不同的类加载器互相之间也是不能访问的。如果你能访问它，那么一定是单例的

